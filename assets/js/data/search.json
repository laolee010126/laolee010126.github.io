[ { "title": "Test", "url": "/posts/test/", "categories": "", "tags": "", "date": "2022-05-27 00:00:00 +0800", "snippet": "2000094805-李成俊练习题1. 因为 JAVA 只允许使用布尔型，跟 C++的非零即真更加靠谱，安全。作业 1k = (j + 13) / 27while k &gt; 10: k += 1 i = 3 * k - 1k = (j + 13) / 27;while(k &lt;= 10){ k++; i = 3 * k - 1;}k = (j + 13) / 27;for k &lt; 10 { k++ i = 3 * k - 1}我觉得三种语言的可读性可写性都不错。作业 3switch(k) { case (k == 1) || (k == 2): j = 2 * k - 1; break; case (k == 3) || (k == 5): j = 3 * k + 1; break; case k == 4: j = 4 * k - 1; break; case (k == 6) || (k == 7) || (k == 8): j = k - 2; break; default: // code block}match k: case (k == 1) | (k == 2): j = 2 * k - 1 case (k == 3) | (k == 5): j = 3 * k + 1 case k == 4: j = 4 * k - 1 case (k == 6) | (k == 7) | (k == 8): j = k - 2 case default: return \"something\"switch k {\tcase (k == 1) | (k == 2): j = 2 * k - 1\tcase (k == 3) | (k == 5): j = 3 * k + 1\tcase k == 4: j = 4 * k - 1\tcase (k == 6) | (k == 7) | (k == 8): j = k - 2\tdefault:\t\t// freebsd, openbsd,\t\t// plan9, windows...\t\tfmt.Printf(\"%s.\\n\", os)\t}作业 5.boolean found = false;for (i = 1, i &lt;= n; i++) { int counter = 0; for (j = 1; j &lt;= n; j++) { if (x[i][j] == 0) counter++; } if (counter == n &amp;&amp; found == false) { cout &lt;&lt; \"First all­zero row is:\" &lt;&lt; i; found = true; }}确实用 goto 可读性更高，容易理解。没有 goto 需要去分析代码，需要思考时间。" }, { "title": "C++ 알고리즘 풀이", "url": "/posts/algorithm/", "categories": "algorithm", "tags": "C++, algorithm", "date": "2022-05-20 00:00:00 +0800", "snippet": "POJ1013 称硬币" }, { "title": "程序设计语言概论5 - 200094805", "url": "/posts/test/", "categories": "程序设计语言概论", "tags": "", "date": "2022-05-12 00:00:00 +0800", "snippet": "作业Write a function reverse which can reverse the elements of a [ ]int slice. It may be applied to slices of any length.func reverse(arr []int) {\tl := len(arr)\tfor i := 0; i &lt; l/2; i++ {\t\tj := l - 1 - i\t\tarr[i], arr[j] = arr[j], arr[i]\t}}Rewrite reverse to use an array pointer instead of a slice.func reverse(arr *[]int) {\tl := len(arr)\tfor i := 0; i &lt; l/2; i++ {\t\tj := l - 1 - i\t\tarr[i], arr[j] = arr[j], arr[i]\t}}Modify reverse to reverse the characters of a [ ]byte slice that represents a UTF-8-encoded string, in place. Can you do it without allocating new memory?import \"unicode/utf8\"func rev(b []byte) {\tsize := len(b)\tfor i := 0; i &lt; len(b)/2; i++ {\t\tb[i], b[size-1-i] = b[size-1-i], b[i]\t}}func reverse(b []byte) {\tfor i := 0; i &lt; len(b); {\t\t_, size := utf8.DecodeRune(b[i:])\t\trev(b[i : i+size])\t\ti += size\t}\trev(b)}Quickimport (\t\"bufio\"\t\"fmt\"\t\"io\"\t\"os\"\t\"sort\"\t\"unicode\"\t\"unicode/utf8\")var stdout io.Writer = os.Stdoutvar stderr io.Writer = os.Stderrvar stdin io.Reader = os.Stdintype RuneSlice []runefunc (p RuneSlice) Len() int { return len(p) }func (p RuneSlice) Less(i, j int) bool { return p[i] &lt; p[j] }func (p RuneSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }func main() {\tcounts := make(map[rune]int) // Unicode characters 个数\tcategories := make(map[string]int) // Unicode characters categories 个数\tvar utflen [utf8.UTFMax + 1]int // UTF-8 encodings 长度\tinvalid := 0 // invalid UTF-8 characters 个数\tin := bufio.NewReader(stdin)\tfor {\t\tr, n, err := in.ReadRune()\t\tif err == io.EOF {\t\t\tbreak\t\t}\t\tif err != nil {\t\t\tfmt.Fprintf(stderr, \"charcount: %v\\n\", err)\t\t\tos.Exit(1)\t\t}\t\tif r == unicode.ReplacementChar &amp;&amp; n == 1 {\t\t\tinvalid++\t\t\tcontinue\t\t}\t\tcountType(r, categories)\t\tcounts[r]++\t\tutflen[n]++\t}\tfmt.Fprintf(stdout, \"rune\\tcount\\n\")\tvar runes []rune\tfor r := range counts {\t\trunes = append(runes, r)\t}\tsort.Sort(RuneSlice(runes))\tfor _, r := range runes {\t\tfmt.Fprintf(stdout, \"%q\\t%d\\n\", r, counts[r])\t}\tfmt.Fprint(stdout, \"\\nlen\\tcount\\n\")\tfor i, n := range utflen {\t\tif i &gt; 0 {\t\t\tfmt.Fprintf(stdout, \"%d\\t%d\\n\", i, n)\t\t}\t}\tif invalid &gt; 0 {\t\tfmt.Fprintf(stdout, \"\\n%d invalid UTF-8 characters\\n\", invalid)\t}\tfmt.Fprint(stdout, \"\\ncategory\\tcount\\n\")\tvar keys []string\tfor k := range categories {\t\tkeys = append(keys, k)\t}\tsort.Strings(keys)\tfor _, k := range keys {\t\tfmt.Fprintf(stdout, \"%s\\t%d\\n\", k, categories[k])\t}}func countType(r rune, categories map[string]int) {\tif unicode.IsControl(r) {\t\tcategories[\"Control\"]++\t}\tif unicode.IsDigit(r) {\t\tcategories[\"Digit\"]++\t}\tif unicode.IsGraphic(r) {\t\tcategories[\"Graphic\"]++\t}\tif unicode.IsLetter(r) {\t\tcategories[\"Letter\"]++\t}\tif unicode.IsLower(r) {\t\tcategories[\"Lower\"]++\t}\tif unicode.IsMark(r) {\t\tcategories[\"Mark\"]++\t}\tif unicode.IsNumber(r) {\t\tcategories[\"Number\"]++\t}\tif unicode.IsPrint(r) {\t\tcategories[\"Printable\"]++\t} else {\t\tcategories[\"NonPrintable\"]++\t}\tif unicode.IsPunct(r) {\t\tcategories[\"Punct\"]++\t}\tif unicode.IsSpace(r) {\t\tcategories[\"Space\"]++\t}\tif unicode.IsSymbol(r) {\t\tcategories[\"Symbol\"]++\t}\tif unicode.IsTitle(r) {\t\tcategories[\"Title\"]++\t}\tif unicode.IsUpper(r) {\t\tcategories[\"Upper\"]++\t}}inserting sorting using a binary tree #include &lt;stdio.h&gt;int binary_search(int a[], int item, int low, int high){ if (high &lt;= low) return (item &gt; a[low])? (low + 1): low; int mid = (low + high)/2; if(item == a[mid]) return mid+1; if(item &gt; a[mid]) return binary_search(a, item, mid+1, high); return binary_search(a, item, low, mid-1);}void insertion_sort(int a[], int n){ int i, location = 0, j, k, selected, n = sizeof(a)/sizeof(a[0]); for (i = 1; i &lt; n; ++i) { j = i - 1; selected = a[i]; location = binary_search(a, selected, 0, j); while (j &gt;= location) { a[j+1] = a[j]; --j; } a[j+1] = selected; }}int main(){ int a[] = {1,2,5,6,3,9,1}; int i = 0; insertionSort(a); printf(\"Sorted array: \\n\"); for (i = 0; i &lt; n; i++) printf(\"%d \",a[i]); return 0;}" }, { "title": "책임에 대한 생각", "url": "/posts/responsibility/", "categories": "생각, 정의", "tags": "책임", "date": "2022-04-16 00:00:00 +0800", "snippet": "책임나는 왜 갑자기 책임에 대해 생각하나?요즘 올웨이즈라는 회사를 찾아보고있었다. 올웨이즈는 가파르게 성정하고 있는 이커머스 스타트업이고, 돈 벌기에 관심 있는 나는 늘 그래왔듯이 올웨이즈라는 사업에 관심이 생겼다. 그러던중 올웨이즈의 채용 설명회를 보게 되었는데, 그 회사 대표가 “7 Standards” 를 만족하는 사람을 찾는다는 말을 했다.&lt;/br&gt;&lt;/br&gt;7Standards 는 Super High Goal:저희는 글로벌 리테일 시장에서의 비효율을 해결하고 아마존을 넘는 이커머스 기업을 만들어나가고자 합니다. 이러한 목표에 진심으로 가슴이 뛰는 팀원과 함께하고 싶습니다. Super Fast:올웨이즈의 폭발적인 성장 속도에 발 맞출 수 있는 팀원과 함께하고 싶습니다. 사고과정에서도, 액션에서도, 배움에 있어서도 모두 최고 속도를 낼 수 있는 팀원과 함께하고 싶습니다. Focused:팀과 함께 비젼과 목표를 달성하는데에 모든것을 걸고 올인 할 수 있는 팀원과 함께하고 싶습니다. Hungry목표를 이루지 못하면 꿈에도 등장할정도로 목표 집착적인 팀원과 함께하고 싶습니다. Humble:본인이 틀릴 수 있다는것을 항상 인지하고, 내가 믿고 있는 사실이 사실이 아닐 수 있기에 늘 열려있는 자세로 탐구하고 대화할 수 있는 팀원과 함께하고 싶습니다. Resilience:수 없이 실패하고 거절당하고 무너지더라도 “뭐..! 다시 해보지 뭐!” 라는 자세로 빠르게 회복하여 다시 일어설 수 있는 팀원과 함께하고 싶습니다. Smart:뛰어난 직관력과 논리적인 사고를 모두 갖춘 팀원과 함께하고 싶습니다. &lt;/br&gt;&lt;/br&gt; 위에같은 내용인데, 내가 바라던 이상향이라 지원서 한번 넣어볼까라는 생각이 들었다. 내가 지금 하고있는 공부, 일이 있는데도 말이다. 여자친구한테 전화가 와서 지금 뭐하고 있어? 라는 말에 쭈뼛거리다 올웨이즈 지원서 적고있다고 말했다. 나도 내가 变来变去한걸 부끄럽다고 생각하긴 했나보다. 여자친구가 갑자기 자기한테 상의도 없이 이런걸 자기 마음대로 결정한다고 속상해하고 화를 내서 책임이라는것에 진지하게 고민을 해봐야겠다고 생각이 들었다. &lt;/br&gt;&lt;/br&gt;“책임” 의 정의내가 책임감이 있는지 없는지, 없다면 어떻게 책임감을 키워야하는지, 꼭 책임감을 키워야만 하는지 등 이러한 질문에 답하기 위해, 나느 책임이라는 단어를 내 스스로 납득할 수 있을만큼 정의하고 넘어가야한다.일단 스스로 정의하자니 책임을 어떻게 정의해야하는지 생각이 잘 안났다. 그래서 일단 다른 사람들은 책임을 어떻게 정의하고 있나 찾아봤다.이러한 정의들이 있었다. 맡아서 행하지 않으면 안 되는 임무. -(옥스포드 사전) 의무를 이행하거나 결정을하거나 무언가를 할 때주의를 기울이는 것. -(어느 블로그 주인장) 책임(責任)이란 단어의 의미를 찾아보면 첫째, 맡아서 해야 할 임무나 의무. 둘째, 어떤 일에 관련되어 그 결과에 대하여 지는 의무나 부담, 또는 그 결과로 받는 제재(制裁). -(국어사전)두번째 정의를 봤을때 가슴이 철렁 했다. 나는 지금까지 어떤 일을 하기전에 주의를 기울이지 않고 일단 몸으로 부딛히고 보는 성격이었다. 그런데 저 블로그 주인장의 정의에 따르면 나는 무책임한 사람이었다. 그래서 가슴이 철렁했다. 나 무책임한 사람이었나? …솔직히 내가 지금까지 몇몇 사람들에게 미안함을 느끼고 있는것도, 지금 이 글을 작성하고 있는것도 스스로를 무책임적인 사람이었다고 생각하니 적고있는것이다. 어느 글에서 본 젊을때는 책임이 별로 없으니 젊을때 많이 도전하고 실패해봐야한다. 우리집 가문은 ‘행’이다 -아버지 등의 말을 내가 해석하고싶은대로 내 마음대로 해석해서, 지금의 무책임한 내가 되버린것만 같았다. 사실 나는 귀찮은일을 미룰수 있는만큼 미루는 사람이기도 하다. 이건 인간 본성이라 어쩔수 없이 꾸준한 반복 학습을 통해 고쳐나가야 하는 좋지못한 인간 본성인것같다. mbti int(p)라 그런가?..&lt;/br&gt;내 스스로에 대한 책임은&lt;/br&gt;무언가를 할 때 주의를 기울이고, 그에 따른 결과를 받아들이는것.남에 대한 책임은&lt;/br&gt;남과 한 약속을 지키는것, 이행하지 않음으로써 피해(물질적이거나 혹은 감정적인)를 입히지 아니할것." }, { "title": "C++ STL", "url": "/posts/STL1/", "categories": "C++", "tags": "STL", "date": "2022-04-11 00:00:00 +0800", "snippet": "C++ STLSTL 개념C++ 의 핵심 - 重用重用 OOP: 继承, 多态, 标准类库(함수, 자료구조, 알고리즘, 네트워크 등) 제네릭 프로그래밍: 템플릿 방식, STL제네릭 프로그래밍 설계템플릿을 이용해서자주 쓰는 자료구조와 알고리즘을 class로 정의 -&gt; 자료구조와 알고리즘을 다시 정의 할 필요가 없음STLSTL: 자주쓰는 자료구조와 알고리즘의 모음STL중 기본개념 컨테이너: 각종 데이터타입을 담을 수 있는 자료구조 이터레이터: 순서대로 컨테이너안의 원소를 넣고 뺄수 있는 도구 (C++에서 포인터는 보통 이터레이터임) 알고리즘: 컨테이너에 동작하는 함수STL 컨테이너크게 3가지 종류로 분류 시퀀스 컨테이너 - vector, deque, list 연관 컨테이너 - set, multiset, map, multimap 컨테이너 어댑터 - stack, queue, priority_queue 컨테이너에 원소를 넣을때 복사본을 만들어서 넣음 많은 STL 알고리즘이 비교연산을 하기때문에(find, sort) “==”, “&gt;”과 같은 연산이 정의되야함.자주 쓰는 연산max_sizesizeswapemptySTL 이터레이터이터레이터: 컨테이너 원소를 가르키는 변수선언 방법:(컨테이너 이름)::iterator 변수;(컨테이너 이름)::const_iterator 변수; (가르키는 원소의 값 변경 불가능) 가리키는 요소의 값에 접근할 수 있어야 합니다. 따라서 참조 연산자(*)가 정의되어야 합니다. 반복자 사이의 대입 연산, 비교 연산이 가능해야 합니다. 따라서 대입, 관계 연산자가 정의되어야 합니다. 가리키는 요소의 주변 요소로 이동할 수 있어야 합니다. 따라서 증가 연산자(++)가 정의되어야 합니다. iterator가 마지막 원소의 뒷 부분 을 만나면 값이 past-the-end가 됨.iterator가 약하냐 강하냐에 따라 기능의 차이가 있음 (5개로 나뉨, 약한거부터 강한거로) 입력 반복자(input iterator) 출력 반복자(output iterator) 순방향 반복자(forward iterator) 양방향 반복자(bidirectional iterator) 임의 접근 반복자(random access iterator)STL 알고리즘（顺序容器） 시퀀트 컨테이너" }, { "title": "C++ 템플릿", "url": "/posts/template/", "categories": "C++", "tags": "template", "date": "2022-04-10 00:00:00 +0800", "snippet": "C++ 템플릿함수 템플릿클래스 템플릿类模版，模版类模版类는 Type마다 갖는다.ex)template&lt;class T1&gt;class Basic { T1 v; public: void printValue() { cout &lt;&lt; v &lt;&lt; endl; }}Baisc&lt;int&gt; a;Baisc&lt;double&gt; b;a, b는 각각 int, double 의 模版类이다.클래스 템플릿의 구성함수를 클래스 밖에 작성하려면, 아래와 같은 형식으로 작성해야한다.template&lt;class T1&gt;class MyClass{ private: T1 value; //class 구성함수와, 구성변수 MyClass(T1 input);}template&lt;class T1&gt;MyClass&lt;T1&gt;::MyClass(T1 input):value(input) {};模版类 = 实例化的类模版클래스 템플릿 구성함수 정의template &lt;class T&gt; // T是模板类CArray&lt;T&gt;的类型参数CArray&lt;T&gt;:: CArray(int length) { //模板类CArray&lt;T&gt;的构造函数ptrElement = new T[length];size = length;}template &lt;class T&gt; // T是模板类CArray&lt;T&gt;的类型参数CArray&lt;T&gt;:: ~ CArray(){ //模板类CArray&lt;T&gt;的析构函数Delete [] ptrElement;}클래스 템플릿 안에 함수 템플릿#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class A{public:template&lt;class T2&gt;void Func(T2 t) { cout &lt;&lt; t; } //成员函数模板};int main() {A&lt;int&gt; a;a.Func(‘K’); //成员函数模板 Func被实例化a.Func(“Hello”); //成员函数模板 Func被实例化return 0;}클래스 템플릿과（类模版） 비 타입형 매개 변수（非类型参数）비 타입형 매게 변수: 클래스 템플릿의 속성 표현하는 값ex》template &lt;class T1, int size&gt;class Array { T array[size]; public: void Print() { for(int i = 0; i &lt; size; i++) { cout &lt;&lt; array[i] &lt;&lt; endl; } }}Araay&lt;int, 40&gt; a1;클래스 템플릿과 상속 클래스 탬플릿 -&gt; 클래스 템플릿 클래스 템플릿 인스턴스 -&gt; 클래스 템플릿 일반 클래스 -&gt; 클래스 템플릿 클래스 템플릿 인스턴스 -&gt; 일반 클래스클래스 템플릿과 friend 함수 함수/클래스/클래스의 구성함수 가 class 템플릿의 friend 함수 템플릿 이 class 템플릿의 friend 함수 템플릿 이 일반 class 의 friend class 템플릿이 class 템플릿의 friend클래스 템플릿과 static 함수클래스 템플릿 인스턴스화 해서 얻은 模版类의 객체들은 같은 static 구성원을 갖게 된다. 함수 템플릿과 클래스 템플릿 정리 String목차 " }, { "title": "로봇OS", "url": "/posts/ROS/", "categories": "AI", "tags": "ai, robotics", "date": "2022-04-07 00:00:00 +0800", "snippet": "ROSROS의 장점ROS 와 OS의 비교Plumbing (消息管道)publish - subscribe 의 방식으로 data 관리Capabilitiesmany libraries, 시간, 모션, 인공지능 등 라이브러리 형태로 제공ROS General Concepts예시:로봇이 이미지 찍어오고, 프로세싱 노드에 넘겨준뒤, laptop에서 볼수있는 거ROS Graph Conept Node Package MetaPackage Topic and Message Service Parameter roscore Launch FileMessage vs. Service vs. Action" }, { "title": "C++ STL", "url": "/posts/stl/", "categories": "C++", "tags": "程序设计", "date": "2022-04-06 00:00:00 +0800", "snippet": "STLSTL 에 하이라이트된 함수만 시험에 나온다.복습STL: 容器+迭代器+算法 容器： 迭代器： 算法：find()函数， copy()函数STL 용기에 객체를 넣으면 실제로 넣어진느것은 복사본이다.무게가 무거운 객체를 넣으면 비용이 크기때문에 포인터를 이용하는 방법도 있다.바이너리 서치중간부터 추축하는 알고리즘 정렬된 배열에서만 사용 가능 顺序容器front(): 용기중에 첫번째 원소 인용 뱉어냄back():push_back(): 용기 뒤에 넣음pop_back(): 용기 뒤에거 삭제vector动态数组v[i] = i;v.at(4) = 100;copy 함수 내부 살현구조template&lt;class InIt, class OutIt&gt;OutIt copy(InIt first, InIt last, OutIt x)templateList 용기下表로 방문 불가능하고, 비교 연산자 사용이 안됨.5 함수 객체함수처럼 보이는 객체class MyAverage { public: double operator() (int a1, int a2, int a3) { return (double) (a1 + a2 + a3) / 3; }}MyAverage Average;cout &lt;&lt; Average(3,2,3);关联容器set / multiset / map / multimapfindlower_boundupper_boundinsertupper_boundlower_bound" }, { "title": "해석학 유클리드 공간 - Accumulation point(聚点，极限点)", "url": "/posts/analysis-accumulation-point/", "categories": "해석학", "tags": "해석학, 유클리드 공간", "date": "2022-04-06 00:00:00 +0800", "snippet": "유클리드 공간 $R_n$1. Euclide space(유클리드 공간)1-1 Vector space(선형 공간)벡터 공간을 얘기기전 벡터의 합과 벡터의 스칼라곱을 정의해야한다. $\\alpha \\in R$ &gt; &gt; $\\vec{x} \\ = \\ (x_1, x_2, …, x_n) \\in R^n$ &gt; $\\vec{y} \\ = \\ (y_1, y_2, …, y_n) \\in R^n$임의의 $\\alpha, \\vec{x},\\vec{y} \\ 에 \\ 대하여$ 벡터 합과 벡터와 스칼라 곱을 아래와 같이 정의한다.\\begin{gather}\\vec{x} \\ 와 \\ \\vec{y} \\ 의 \\ 합 \\ 정의\\\\\\vec{x} + \\vec{y} \\ = \\ (x_1 + y_1, x_2 + y_2, …, x_n + y_n)\\end{gather}\\begin{gather}a 와 \\ \\vec{x} \\ 의 \\ 곱 \\ 정의\\\\a\\vec{x} \\ = \\ (ax_1, ax_2, …, ax_n)\\end{gather}또한 zero element(零元) 이랑 unit element(单位元)은 아래와 같이 정의한다.$\\exists \\vec{0} \\in R^n \\ s.t \\ \\forall \\vec{x} \\in R^n$\\begin{gather}\\vec{x} \\ + \\ \\vec{0} \\ = \\ \\vec{x} \\ ;\\end{gather}$\\exists 1 \\in R \\ s.t \\ \\forall \\vec{x} \\in R^n$\\begin{gather}1\\vec{x} \\ = \\ \\vec{x} \\ ;\\end{gather} 정의: 위에 나오는 선형 연산들을 부여한 $R^n$ 을 n demendion vector space 라고 한다.1-2 Definition of Euclide space(유클리드 공간 정의)위에서 정의한 선형공간에 내적(dot product) 이라는 연선을 추가해 유클리드 공간을 정의한다.Dot product(내적)\\begin{gather}\\vec{x}\\vec{y} \\ = \\ \\sum_{i=-1}^{n} x_iy_i\\end{gather}벡터공간에 내적 연산을 추가함으로써 유클리드 공간이 정의된다.2. Limit of dot sequence(점 수열 극한)점 수열의 극한 이해: 점들이 마지막에 한 점으로 모인다.정리 13.1.1 (点列 극한 &lt;=&gt; 벡터의 한 원소 의 극한 = 극한 벡터의 대응 원소)$\\lim_{k\\to\\infty} \\{\\vec{x}_k\\} \\ = \\ \\vec{x}_0 $$\\Leftrightarrow $$\\forall i \\ \\lim_{k\\to\\infty} x_i^k = x_i^0$点列极限性质 $\\{x_k\\}$ 극한이 존재할때, 극한값은 유일하다. $\\{x_k\\}$ 극한이 존재할때, $\\{x_k\\}$ 는 유계이다. 벡터극한의 내적, 벡터극한과 스칼라의 곱, 벡터극한끼리 더하기 가능.3. Accumulation point3-1 Definition of accumulation point정의:$E$ 는 $E \\subset{R^n}$ 를 만족하는 주어진 집합이라고 설정한다. 만약 $x \\in R^n$ 의 임의의 $\\delta$ 구역 $U(\\vec{x}, \\delta), (\\delta &gt; 0)$ 에 $E$ 중 $\\vec{x}$ 와 다른 점 이 존재한다면, $\\vec{x}$ 는 accumulation point(聚点) 혹은 극한점(极限点)이라고 한다. 聚点의 존재 의의는 어떤 점이 聚点이면 그 점에서 극한을 취할 수 있다.3-2 isolated point정의:$\\vec{x} \\in E$ 에대하여, $\\exists \\ \\delta_0 \\ s.t \\ \\vec{x} \\notin U_0(\\vec{x}, \\delta_0)$ 이러한 점을 isolated point(孤立点)라고 한다. E에 포함되지만, 聚点은 아닌 点을 isolated point(孤立点)라고 이해하면 된다.开集，闭集중요한 세가지 점들 内点($E^\\circ$): 孤立点이 아닌 범위 내의 점 外点($(E^c)^\\circ$): 범위의 테두리가 아닌 바깥점 边界点$(\\partial E)$: 범위의 테두리 + 孤立点 总结: 聚点은 内点 + 테두리점들；孤立点은 혼자 떨어져있는 점들开集，闭集 开集: $E = E^\\circ$ 闭集: $E^c = (E^c)^\\circ$开集，闭集성질 开集的性质 $R^n$ 与 $\\empty$ is open set 任意个开集的并是开集 " }, { "title": "C++ 가상함수 문제풀이5", "url": "/posts/virtual5/", "categories": "C++", "tags": "C++, 가상함수", "date": "2022-04-05 00:00:00 +0800", "snippet": "5번째 문제 - 怎么又是 Fun 和 Do문제#include &lt;iostream&gt;using namespace std;class A {\tprivate:\tint nVal;\tpublic:\tvoid Fun()\t{ cout &lt;&lt; \"A::Fun\" &lt;&lt; endl; };\tvirtual void Do()\t{ cout &lt;&lt; \"A::Do\" &lt;&lt; endl; }};class B:public A {\tpublic:\tvirtual void Do()\t{ cout &lt;&lt; \"B::Do\" &lt;&lt; endl;}};class C:public B {\tpublic:\tvoid Do( )\t{ cout &lt;&lt;\"C::Do\"&lt;&lt;endl; }\tvoid Fun()\t{ cout &lt;&lt; \"C::Fun\" &lt;&lt; endl; }};void Call(// 在此处补充你的代码) {\tp-&gt;Fun(); p-&gt;Do();}int main() {\tCall(new A());\tCall(new C());\treturn 0;}输入无输出A::FunA::DoA::FunC::Do답 &amp; 해설이문제는 기본적인 기본적인 virtual의 동작을 물어보는 문제이다.먼저 이 문제의 답을 알아보자.#include &lt;iostream&gt;using namespace std;class A {\tprivate:\tint nVal;\tpublic:\tvoid Fun()\t{ cout &lt;&lt; \"A::Fun\" &lt;&lt; endl; };\tvirtual void Do()\t{ cout &lt;&lt; \"A::Do\" &lt;&lt; endl; }};class B:public A {\tpublic:\tvirtual void Do()\t{ cout &lt;&lt; \"B::Do\" &lt;&lt; endl;}};class C:public B {\tpublic:\tvoid Do( )\t{ cout &lt;&lt;\"C::Do\"&lt;&lt;endl; }\tvoid Fun()\t{ cout &lt;&lt; \"C::Fun\" &lt;&lt; endl; }};void Call(// 在此处补充你的代码//답A *p//) {\tp-&gt;Fun(); p-&gt;Do();}int main() {\tCall(new A());\tCall(new C());\treturn 0;}나의 분석 흐름을 따라와보자. 일단 Call 함수 내부를 보면, p-&gt;Fun(), p-&gt;Do() 처럼 ‘변수-&gt;함수()’의 형태로 함수를 호출하고 있다. 따라서, p는 포인터라는 사실을 인지했다. 다음으로 p가 어떤 class의 포인터인지 확인해야한다. main함수에서 Call(new A()) Call(new C()) 이런식으로 Call의 인자로 각각 A객체와 C객체를 전달해주었다. A,B,C class 모두 인자의 타입으로 들어올 수 있는데먼저 A class가 인자타입일때를 확인해보면, 첫번째 Call함수에서 p는 A객체를 인자로 받았고, p-&gt;Fun()은 “A::Fun”을 출력한다. p-&gt;Do()는 “A::Do”를 출력하다.두번째 Call함수에서 p는 C객체를 인자로 받았다. p-&gt;Fun() 은 “A::Fun”을 출력하게 된다. 왜냐하면, A class에서 Fun이 virtual로 정의되지않았기때문에 p-&gt;Fun()은 A class의 Fun 함수를 실행시키기때문에 “A::Func”이 출력이되는것이다. p-&gt;Do() 는 “C::Do”를 출력하게 된다. 왜냐하면 A class에서 Do함수는 virtual로 정의되었기때문에 포인터가 가르키는 객체에 존재하는 Do함수를 실행시킨다. (B class의 virtual Do에서 virtaul를 지우면 A::Do가 실행되는지 확인해봤는데, 안된다. 앞에서 배웠던 가장 기초가 되는 class에서 특정함수를 virtual로 정의하면 나머지 자식들은 virtual를 써주지않아도 virtual로 정의된다는 사실을 다시한번 알아볼 수 있었다.)그러므로 이 문제의 답은 위와 같다." }, { "title": "C++ 가상함수 문제풀이4", "url": "/posts/virtual4/", "categories": "C++", "tags": "C++, 가상함수", "date": "2022-04-05 00:00:00 +0800", "snippet": "4번째 문제 - 怎么又是 Fun 和 Do문제#include &lt;iostream&gt;using namespace std;class A {\tprivate:\tint nVal;\tpublic:\tvoid Fun()\t{ cout &lt;&lt; \"A::Fun\" &lt;&lt; endl; };\tvirtual void Do()\t{ cout &lt;&lt; \"A::Do\" &lt;&lt; endl; }};class B:public A {\tpublic:\tvirtual void Do()\t{ cout &lt;&lt; \"B::Do\" &lt;&lt; endl;}};class C:public B {\tpublic:\tvoid Do( )\t{ cout &lt;&lt;\"C::Do\"&lt;&lt;endl; }\tvoid Fun()\t{ cout &lt;&lt; \"C::Fun\" &lt;&lt; endl; }};void Call(// 在此处补充你的代码) {\tp-&gt;Fun(); p-&gt;Do();}int main() {\tCall(new A());\tCall(new C());\treturn 0;}输入无输出A::FunA::DoA::FunC::Do답 &amp; 해설이문제는 기본적인 기본적인 virtual의 동작을 물어보는 문제이다.먼저 이 문제의 답을 알아보자.#include &lt;iostream&gt;using namespace std;class A {\tprivate:\tint nVal;\tpublic:\tvoid Fun()\t{ cout &lt;&lt; \"A::Fun\" &lt;&lt; endl; };\tvirtual void Do()\t{ cout &lt;&lt; \"A::Do\" &lt;&lt; endl; }};class B:public A {\tpublic:\tvirtual void Do()\t{ cout &lt;&lt; \"B::Do\" &lt;&lt; endl;}};class C:public B {\tpublic:\tvoid Do( )\t{ cout &lt;&lt;\"C::Do\"&lt;&lt;endl; }\tvoid Fun()\t{ cout &lt;&lt; \"C::Fun\" &lt;&lt; endl; }};void Call(// 在此处补充你的代码//답A *p//) {\tp-&gt;Fun(); p-&gt;Do();}int main() {\tCall(new A());\tCall(new C());\treturn 0;}나의 분석 흐름을 따라와보자. 일단 Call 함수 내부를 보면, p-&gt;Fun(), p-&gt;Do() 처럼 ‘변수-&gt;함수()’의 형태로 함수를 호출하고 있다. 따라서, p는 포인터라는 사실을 인지했다. 다음으로 p가 어떤 class의 포인터인지 확인해야한다. main함수에서 Call(new A()) Call(new C()) 이런식으로 Call의 인자로 각각 A객체와 C객체를 전달해주었다. A,B,C class 모두 인자의 타입으로 들어올 수 있는데먼저 A class가 인자타입일때를 확인해보면, 첫번째 Call함수에서 p는 A객체를 인자로 받았고, p-&gt;Fun()은 “A::Fun”을 출력한다. p-&gt;Do()는 “A::Do”를 출력하다.두번째 Call함수에서 p는 C객체를 인자로 받았다. p-&gt;Fun() 은 “A::Fun”을 출력하게 된다. 왜냐하면, A class에서 Fun이 virtual로 정의되지않았기때문에 p-&gt;Fun()은 A class의 Fun 함수를 실행시키기때문에 “A::Func”이 출력이되는것이다. p-&gt;Do() 는 “C::Do”를 출력하게 된다. 왜냐하면 A class에서 Do함수는 virtual로 정의되었기때문에 포인터가 가르키는 객체에 존재하는 Do함수를 실행시킨다. (B class의 virtual Do에서 virtaul를 지우면 A::Do가 실행되는지 확인해봤는데, 안된다. 앞에서 배웠던 가장 기초가 되는 class에서 특정함수를 virtual로 정의하면 나머지 자식들은 virtual를 써주지않아도 virtual로 정의된다는 사실을 다시한번 알아볼 수 있었다.)그러므로 이 문제의 답은 위와 같다." }, { "title": "C++ 가상함수 문제풀이3", "url": "/posts/virtual3/", "categories": "C++", "tags": "C++, 가상함수", "date": "2022-04-05 00:00:00 +0800", "snippet": "3번째 문제 - 这是什么鬼 delete문제#include &lt;iostream&gt;using namespace std;class A{public:\tA() { }// 在此处补充你的代码};class B:public A {\tpublic:\t~B() { cout &lt;&lt; \"destructor B\" &lt;&lt; endl; }};int main(){\tA * pa;\tpa = new B;\tdelete pa;\treturn 0;}输入无输出destructor Bdestructor A답 &amp; 해설이문제는 상속관계에서 Base, Derived의 소멸자 함수 사용에 관한 개념을 물어보는 문제이다.Base class의 포인터를통해 Derived class의 객체를 삭제한다면, 이때 오직 Base의 소멸자 함수만을 호출하게 된다.class Base { ~Base() { cout &lt;&lt; \"Base::destructor called\" &lt;&lt; endl; }};class Derived { ~Derived() {cout &lt;&lt; \"Derived::destructor called\" &lt;&lt; endl; }}int main () { Base *pBase = new Derived; delete pBase; return 0;}outputBase::destructor called이렇게 되면 실제 Derived 객체가 메모리상에서 소멸한게 아니기때문에, 프로그램에 부담으로 남게된다. 어떻게 Derived의 객체도 삭제할 수 있을까? 다시말해 어떻게 Derived의 소멸자 함수를 호출할 수 있을까? 정답은 Base class 소멸자 함수에 virtural을 부여해 위에 기능을 구현할 수 있다.class Base { ~Base() { cout &lt;&lt; \"Base::destructor called\" &lt;&lt; endl; }};class Derived { virtual ~Derived() { cout &lt;&lt; \"Derived::destructor called\" &lt;&lt; endl; }}int main () { Base *pBase = new Derived; delete pBase; return 0;}outputDerived::destructor calledBase::destructor called따라서 위 문제의 답은 아래와 같다.virtual ~A() { cout &lt;&lt; \"destructor A\" &lt;&lt; endl; }" } ]
